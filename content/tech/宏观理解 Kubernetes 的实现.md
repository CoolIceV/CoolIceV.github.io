---
title: <div class="custom-title">宏观理解&nbsp;<div class='reverse'>Kubernetes</div>&nbsp;的实现</div>
date: "2022-12-15T14:45:15+08:00"
tags: ["Cloud Native", "Kubernetes", "云原生"]
slug: "understand-kubernetes-in-global-view"
indentFirstParagraph: true
indent: false
dropCapAfterHr: true
dropCap: false
# toc: true
tocNum: false
draft: true
---

{{<quote >}}
这是我一年前在字节跳动实习时写的一篇学习笔记，简要叙述了《Kubernetes in Action》中的大部分内容，当时发表在了 ByteTech 上。最近打算对其进行重新整理，并计划补充 CRD、Informer、Helm、KubeFed、HNC、CNI 等内容。虽然文章讲解的不算深入，但对于想要相对宏观了解 Kubernetes 的人来说还是可以一读的。本讲作为云原生系列文章的第一篇，随后还打算简单介绍一下边缘计算、服务网格、函数计算、持续交付、混沌工程等相关内容。
{{</quote >}}

---
云原生可以说是近年来最火的概念之一，云原生并不是某种具体的技术，而是一种应用设计思想，即应用程序原生为云设计，从设计之初就考虑云的环境，充分发挥云平台的弹性和分布式优势。在云原生领域中，Kubernetes 可以说是目前具有统治地位的一个工具，已成为云原生领域开发的事实标准，也正因为这个工具，越来越多的企业才能够以较低的成本搭建和维护私有云环境，实现应用的持续性交付，加速软件的迭代升级。因此，理解 Kubernetes 十分重要，属于云原生系列文章的基础，后面的内容也基本都会基于 Kubernetes 框架介绍。

本文我们更注重 Kubernetes 的核心概念，从宏观上理解 Kubernetes 的实现思想，而不是如何使用 Kubernetes，自然也不会过分的关注具体细节。

## 一、什么是 Kubernetes

Kubernetes 是一个容器应用的分布式自动化管理平台，目前已经广泛应用在生产环境中，是近几年最热门的的技术之一。Kubernetes 是希腊语『舵手』的意思，它是 Google 实现的 Borg 的开源方案，由于 K 和 s 之间有 8 个字符，一般被缩写为 K8s。

![Kubernetes](/images/宏观理解Kubernetes的实现/k8s-intro.svg "Kubernetes")

K8s 相当于云原生时代的“操作系统”，它部署在集群之上的，在底层基础架构和设施之上提供了一个具有海量资源与算力的抽象层，使数以千计的计算机节点相互协调运作，使用容器技术和微服务架构对应用进行自动化编排与调度。开发人员通过 K8s 部署应用或服务时无需关心底层计算机和基础架构，更不必手动到每台机器上操作，极大程度上简化了服务的部署运维流程。更重要的是，K8s 具有服务、节点健康检查与自修复功能，当服务/节点出现故障之时，可以自动在可用节点上重建服务，使整个系统所提供的服务仍处于期望的状态。

### Kubernetes 的两大相关技术

K8s 之所以能够逐渐被广泛应用，与容器技术和微服务架构的迅速发展离不开关系，我们在这里简单介绍一下这两大技术：

#### 第一个技术：容器技术

容器技术让开发人员可以将自己应用和依赖环境打包到一个可移植的容器中，让应用的运行与环境无关。容器与虚拟机类似，每个容器具有自己的文件系统、进程空间以及CPU和内存限制等，不同的是，容器并没与像虚拟机一样虚拟出硬件与内核，而是使用宿主机的硬件与内核，因此，容器会比虚拟机更轻量，资源利用率也更高。下面这张图比较清晰得展示了虚拟机和容器的最大的区别，可以看到容器是比较轻量的，调用流程也更简单，不会向虚拟机一样占用过多的资源。

![VM 与 Container 对比](/images/宏观理解Kubernetes的实现/container.svg "VM 与 Container 对比")

Docker 可以说是当前容器技术的标准，在多数生产环境中的云环境也都是使用的 Docker 作为运行环境。但是事实上，在 2020 年 12 月，K8s 社区决定移除仓库中支持 Docker 的代码，主要原因是 Docker 并没有实现 K8s 需要的 CRI（容器运行时接口 Container Runtime Interface），之前都是由 K8s 社区来实现和维护一个叫 dockershim 的组件，对于今天已经统治市场的 K8s 来说，支持 Docker 的维护成本过于昂贵，而且也不符合 K8s 高扩展性的发展目标，因此不再进行维护。但现在已经 Docker 已经使用 cri-dockerd 支持了 K8s 所需要的接口。

#### 第二个技术：微服务架构
随着现在软件越来越复杂，一个完整的应用不再是单体服务，而是被拆分成多个核心功能，每个功能都被称为一项服务，具有特定的职责和功能，可以单独构建和部署，这也就意味着各个服务在工作甚至出现故障时不会相互影响，这种应用的实现方式被称为微服务架构。但微服务个数的增多意味着链路的延长，响应的时延也会随之增大，为了降低处理时延，微服务架构又出现了合并部署的趋势，将相关联的服务在云环境中部署的尽可能靠近，并利用 Service Mesh 技术进行流量调度，将微服务进行“合并”。

![服务架构](/images/宏观理解Kubernetes的实现/service-arch.svg "服务架构")

### Kubernetes 的三大核心能力

#### 第一个核心能力：编排调度

K8s 可以把服务资源请求与实际剩余资源进行自动编排分配，将服务实例分配到集群的具体节点上，用户无需感知被分配到了哪台机器上，这种自动化编排的方式除了能够减少人力还能有效提升资源利用率。此外，K8s 还会对服务的全生命周期进行监控管理控制，极大程度上简化了操作。

#### 第二个核心能力：自动修复

K8s 可以对节点甚至容器进行健康检查，当有一个节点出现问题时，K8s 会将这个节点上的所有容器自动迁移到其他节点上，如果容器出现了问题会对这个容器进行重启，来实现自动修复的功能。不止节点和容器，任何其他资源甚至自定义的资源都能够很容易实现自动修复的逻辑。

#### 第三个核心能力：弹性伸缩

K8s 有业务负载检查的功能，它会监测业务上所承担的负载，并根据负载情况对服务副本个数甚至服务资源配置进行弹性调整。K8s 为我们提供了一个能够自动进行扩缩容的对象 HPA，HPA 会针对每一个指标使用所有容器的平均值除以目标值得到应有的副本数，然后所有指标计算出的结果中取最大值，根据这个值对服务实例进行水平扩缩容。

![HPA](/images/宏观理解Kubernetes的实现/hpa.svg "HPA")

HPA 是支持一些更高级的配置的，比如最大的副本数、最小的副本数、每次扩缩容影响实例个数的比例等，还可以使用自定义指标，具体的可以查看 [Pod 水平自动扩缩 | Kubernetes](https://kubernetes.io/zh/docs/tasks/run-application/horizontal-pod-autoscale/)。


## 二、Kubernetes 的管理

我们对 K8s 集群的管理都是通过客户端调用 K8s 提供的 API 来进行管理，最常用的一个工具是 kubectl，它是一个命令行工具，利用 K8s 的 API 整合出了一系列功能强大的命令，也就是说，运行一个 kubectl 命令在背后可能是调用了数个原生 API。我们并不介绍如何使用 kubectl，因为官方的文档和网络上的相关博客已经介绍的十分全面了，想要实现什么操作在网络上都可以找到命令及示例，感兴趣的可以 [点击学习如何使用kubectl](https://kubernetes.io/zh/docs/reference/kubectl/)。

接下来我们来看一些与管理相关的比较“抽象”的内容。

### 第一个概念：对象

K8s 中的对象是系统中持久化的实体，它们表示的是集群的状态，也可以被称为“资源”。这些对象描述了哪些应用或服务应该以怎样的规格运行在集群中，每对一个对象进行增删改查操作，都是对集群状态的修改。K8s 使用声明式的方式定义对象，我们并不告诉 K8s 具体要干什么，只告诉 K8s 我们期望的一个稳定的状态，然后K8s会进行编排、管理来达到这个状态。

接下来介绍一下怎么描述一个具体的 K8s 对象以及它是以什么形式存储的。

**如何描述**

我们可以使用 JSON 或 YAML 格式的数据来描述一个对象，每一个对象都包括以下四个部分：
- Type Metadata：API 组和类型，这一部分包含了这个对象的类型，K8s 的对象是根据 API 版本分组进行管理的，不同类型的资源可能在不同的组或版本下，我们通过这一部分明确的告诉 K8s 对象的类型。
- Object Metadata：元数据，这一部分描述的是对象的基本信息，包括对象名称、创建时间、标签、命名空间和其他来标识对象的信息，我们获取对象的时候是根据这部分的信息中的名称、命名空间、标签等进行匹配的。

以上两部分对于所有对象来说字段都是相同的，而接下来两个字段不同类型的对象拥有着不同的定义。

- Spec：对象的规格，这部分详细描述了对象的内容，是我们期望的对象的状态，里面包含了该对象需要的资源以及策略，K8s 的调度其实就是不断进行操作来使集群达到或处于这部分的状态。
- Status：对象当前的状态，这部分描述的是对象在 K8s 中某一具体时间的实际状态，这一部分会表明 K8s 实际为该对象分配的资源以及该对象所处的生命周期阶段，同时还会包括该对象最近产生的变化以及对应的原因等信息，K8s 会一直监听该对象来使该对象的实际状态与 Spec 描述的一致。

![Kubernetes 对象](/images/宏观理解Kubernetes的实现/object.svg "Kubernetes 对象")


**如何存储**

我们再来说一下 K8s 是怎么存储对象的，K8s 会将所有的对象存储在 etcd（分布式统一键值存储）中，对象的键是 `/registry/{对象类型}/{对象命名空间}/{对象名称}`，而对象的值就是我们刚刚介绍的这些内容的 json 格式，在比较旧的 K8s 版本中是明文存储的，1.7 版本之后 K8s 对内容进行了加密。
```shell
$ etcdctl get /registry/pods/default/kubia-manual 
{"kind":"Pod","apiVersion":"v1","metadata":{"name":"kubia-manual", ...
```

### 第二个概念：标签
在 K8s 中，最基本也是最重要的对象是一种被称为Pod 的资源，Pod 内部会运行若干个容器来提供服务，每个服务的一个实例（副本）就是一个 Pod，我们对一个服务的最基本的管理就是对 Pod 的管理。

微服务架构的系统会有大量的服务部署在 K8s 上，每个服务又可能会同时部署了多个版本，每个版本又具有多个副本，这就会导致系统中会有着数千甚至上万个 Pod，而且这些 Pod 又是“混乱”得分布在各个节点上，我们不可能一个 Pod 一个 Pod 得进行管理，我们肯定更希望能够将对其中一个子集进行（批量）管理，K8s 使用标签为我们提供了一种简单但又十分强大的管理功能。

![Kubernetes Pod](/images/宏观理解Kubernetes的实现/label-1.svg "Kubernetes Pod")

标签是 K8s 对象的一个十分重要的特性，一个标签就是一个的 k-v 键值对，我们可以为 K8s 的任意对象添加标签，之后我们便可以通过标签筛选出一个集合的对象来进行管理，标签的添加或修改可以在对象创建之前也可以在创建之后，这为我们提供了比较大的灵活性。

我们为上图所示的所有 Pod 都添加两个标签，一个是 *app*，代表这个 Pod 属于哪个服务，还有一个是 *rel*，表示这个 Pod 运行的服务是稳定版还是体验版或者小流量版。添加完成之后，我们就为这些 Pod 建立起了一个二维的管理空间，如下图所示，我们可以通过`rel=canary`选中所有小流量版本的 Pod，也可以通过`rel=beta, app=as`选中所有测试版的 Account 服务的 Pod，然后我们便可以对选中的所有 Pod 进行批量管理。

![Kubernetes 标签](/images/宏观理解Kubernetes的实现/label-2.svg "Kubernetes 标签")

一些高级对象如 ReplicaSet、Deployment 其实也是通过标签来管理的 Pod，这个我们后面会介绍到。不只是 Pod，所有对象集合的筛选基本都是基于标签匹配的。

### 第三个概念：命名空间

标签为我们提供了一个十分强大的管理方式，但是如果有多个团队在同一 K8s 集群上操作，很有可能会误操作，而且标签是很有可能会重复的，这样一个团队进行操作时很有可能会影响到另一个团队的服务，这肯定是我们不希望看到的。

为了隔绝不同团队的操作，Kubernetes 支持通过命名空间（Namespace）在一个物理集群中划分出多个相对独立的虚拟空间，这些虚拟空间就是单独的命名空间。不同的命名空间之间的资源在管理上是隔离，这样我们就可以不重不漏地将所有的对象分成若干个组，然后在某个组上再对对象进行操作。

![Kubernetes 命名空间](/images/宏观理解Kubernetes的实现/namespace.svg "Kubernetes 命名空间")

需要说明的是命名空间仅仅是对资源的管理进行了隔离，但是部署的节点并不是隔离的，不同命名空间之间的网络是否隔离也是由网络架构来决定。

在 K8s 中，Namespace 同样也是一个对象，正如前面所说的，凡是我们对 K8s 的状态进行修改，基本都是对对象的修改。

### 第四个概念：API

前面讲到，对 K8s 的操作都是通过 API，K8s 提供的 API 是基于 HTTP 的 RESTful API，对资源的查询、创建、修改、删除与 HTTP 方法GET、POST、PUT/PATCH、DELETE 对应，每个资源都有一个唯一标识的统一资源标识符，也就是请求的 PATH 中就是具体的某个资源，下面这张图举了个简单的例子：

![Kubernetes API](/images/宏观理解Kubernetes的实现/api.svg "Kubernetes API")

可以看到，每个资源的路径最开始都是以 API 组和版本开始的，然后是命名空间（集群级别的对象是没有命名空间的），然后是具体的对象类型以及对象的名称，API 的路径规则在一定程度上也反映了K8s使用命名空间隔离对象的管理的一种思想。

### 小结

我们简单介绍了 K8s 对对象的组织管理方式，简单来说，K8s 中每种对象会被至少一个 API 组来管理着，然后使用命名空间将整个集群划分成不重叠的若干个独立单元，每个单元中会有若干个对象，我们可以使用标签筛选出一个特定的对象子集，然后对这个集合的对象进行统一操作和管理，接下来我们来看几个具体的对象。

## 三、Kubernetes 上的工作负载

### 基本调度单元 Pod

#### 内部结构

#### 生命周期

### 自动管理 Pod 的资源 ReplicaSet & Deployment

### 提供稳定访问能力的资源 Service

### 小结


## 四、Kubernetes 的架构

### 第一部分：核心组件

### 第二部分：组件通信

### 第三部分：提高集群可用性


## 五、Kubernetes 的调度流程

### 理解资源分配

### Deployment 是怎么产生的 Pod


## 六、高级 Kubernetes

### 用户自定义资源 CRD 与控制器模式

### Webhook 模式

### 监听组件 Informer


## 七、扩展 Kubernetes

### 应用管理工具 Helm

### 联邦集群 KubeFed

### 层级命名空间 HNC

### 网络方案 Calico

## 八、总结